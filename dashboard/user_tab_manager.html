<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
  </head>
<style>
html, body {
  width: 100%;
  min-width: 300px;
}

.hidden {
  display: none;
}

.button {
  margin: 3% auto;
  padding: 4px;
  text-align: center;
  font-size: 1.5em;
  cursor: pointer;
}

button {
  cursor: pointer;
}

.word-divs {
  margin-bottom: 4px;
}


.ulist {
  background-color: #11531f;
  color: white;
}
.ulist:hover {
  background-color: #cfeeee;
  color:#11531f
}

.cluster {
  background-color: #11531f;
  color: white;
}
.cluster:hover {
  background-color: #cfeeee;
  color:#11531f
}

.saver {
  background-color: #E5F2F2;
}
.saver:hover {
  background-color: #BFF2F2;
}


.reloader {
  background-color: #FBFBC9;
}
.reloader:hover {
  background-color: #DAEA9D;
}

.shutdown {
  background-color: #FBFBC9;
}
.shutdown:hover {
  background-color: #EAEA9D;
}


.wulist {
  background-color: #11531f;
  color: white;
}
.wulist:hover {
  background-color: #cfeeee;
  color:#11531f
}


.user-name {
  font-weight: 800;
  font-size: larger;
  color:rgb(122, 27, 3)
}

.wsaver {
  background-color: #E5F2F2;
}
.wsaver:hover {
  background-color: #BFF2F2;
}


.wgetter {
  background-color: #FBFBC9;
}
.wgetter:hover {
  background-color: #EAEA9D;
}


.dashboard_getter {
  background-color: #FBFBC9;
  color:#064614;
}
.dashboard_getter:hover {
  background-color: #f0e19e;
  color:#053a10;
}


.help_getter {
  background-color: #FBFBC9;
  color:#064614;
}
.help_getter:hover {
  background-color: #EAEA9D;
  color:#064614;
}

.saver-help {
  color : #FBFBC9;
  font-size:smaller;
  font-family:Georgia, 'Times New Roman', Times, serif;
}


.do_clear {
  color:#064614;
}
.do_clear:hover {
  background-color: #EAEA9D;
  color:#064614;
}

.do_undo {
  color:#064614;
}
.do_undo:hover {
  background-color: #EAEA9D;
  color:#064614;
}


.counter_box {
  margin-left: 4px;
  margin-right: 4px;
  padding: 2px;
  color: rgb(39, 33, 73);
  font-size: 75%;
}


 /* Style the tab */
 .tab {
  overflow: hidden;
  border: 1px solid #ccc;
  background-color: #f1f1f1;
}

/* Style the buttons that are used to open the tab content */
.tab button {
  background-color: inherit;
  float: left;
  border: none;
  outline: none;
  cursor: pointer;
  padding: 14px 16px;
  transition: 0.3s;
}

/* Change background color of buttons on hover */
.tab button:hover {
  background-color: #ddd;
}

/* Create an active/current tablink class */
.tab button.active {
  background-color: #ccc;
}

/* Style the tab content */
.tabcontent {
  display: none;
  padding: 6px 12px;
  border: 1px solid #ccc;
  border-top: none;
} 

.tabcontent-sub {
  padding: 6px 12px;
  border: 1px solid #ccc;
  border-top: none;
} 


.tabcontent-sub-tight {
  padding: 0px 12px;
  border: 1px solid #ccc;
  border-top: none;
} 

.PhIOtjDr_0 {
  fill:none;
  stroke:#1c1448;
  stroke-width:4.59875107;
  stroke-miterlimit:4;
  stroke-dasharray: 2948 2950;
  stroke-dashoffset: 2949;
  animation: PhIOtjDr_draw 6666ms ease-in forwards;
}

@keyframes PhIOtjDr_draw {
  100% {stroke-dashoffset: 0}
}

@keyframes PhIOtjDr_fade {
  0% {stroke-opacity: 1}
  97.1830985915493% {stroke-opacity: 1}
  100% {stroke-opacity: 0}
}


.edit-ops-container {
  width : 100%;
  background-color: rgb(246, 253, 241);
  border: solid 1px rgb(46, 39, 92);
  vertical-align: top;
  height: 400px;
}

.edit-left {
  display:inline-block;
  border: solid 1px green;
  width: 30%;
  height: inherit;
  overflow: auto;
}
.edit-center {
  display:inline-block;
  border: solid 1px green;
  width: 35%;
  height: inherit;
  overflow: auto;
}
.edit-right {
  display:inline-block;
  border: solid 1px green;
  width: 30%;
  height: inherit;
  overflow: auto;
}

.edit-center-content {
  display: grid;

  grid-template-columns: repeat(5, 1fr);
  column-gap: 6px;
  row-gap: 1em;
  width: inherit;
  height: fit-content;
  padding:2px;
}


.edit-center-content-wrapper {
  border: solid 1px blue;
  background-color: rgb(255, 255, 245);
  font-weight: bold;
  color:rgb(18, 31, 70);
  padding: 2px;
}


.edit-center-dropper {
  width:  fit-content;
  height: fit-content;
  padding: 4px;
  border: solid 1px goldenrod;
  background-color: lightgoldenrodyellow;
}


.drag_link {
  color:darkslateblue;
  cursor: grab;
}

.drag_link:active {
  color:darkslateblue;
  cursor: grabbing;
}


.display-button {
  font-weight:bold;
  width:98%;
  font-size: 0.90em;
  padding-left: 2px;
  padding-right: 2px;
  margin-bottom: 4px;
  border: darkolivegreen 1px solid;
  border-radius: 25px;
  cursor: pointer;
}

.display-button:hover {
  background-color: whitesmoke;
}

.display-button:active {
  background-color: rgb(207, 243, 192);
}


</style>
<body>
  <div id="popup-content">
    <div style="background-color: blanchedalmond;padding: 4px;border: 1px solid rgb(82, 9, 82)">
      <div style="width:38;height:38;display:inline-block">
        <a class="nav-link" href="http://www.copious.world" target="COPIOUS">
            <svg version="1.0" width="38" height="38" viewBox="0 0 250 250" preserveAspectRatio="xMidYMid meet" id="logo" >
              <defs id="defs10"/>
              <path class="PhIOtjDr_0"  id="path6" d="m 30.107062,7.4672872 c 4.67725,2.6985208 8.37554,8.6930958 12.94402,20.5087688 7.17904,19.072767 24.58277,67.337762 29.69511,82.950634 l 5.32989,15.9502 -13.70543,-0.25058 -10.468161,2.57106 -8.132079,2.99946 -4.78602,5.90784 0.76141,-6.91979 c 0.65264,-6.50536 0.32632,-7.85462 -5.43866,-25.31791 C 27.822822,80.549048 20.535012,60.127019 12.703332,40.215781 5.4155222,21.730904 4.4365622,15.57249 7.8085322,10.503124 11.941922,4.43145 22.384152,2.9954505 30.107062,7.4672872 Z M 238.08162,22.742849 c 3.69828,2.110631 6.52639,6.669206 6.52639,10.379672 0,1.686578 -2.93688,12.740881 -6.63517,24.469814 -19.68797,64.138095 -30.34775,107.931245 -30.34775,124.806655 0,4.6453 -1.08775,7.68113 -18.60024,50.80931 l -4.35093,10.79409 -67.76577,0 -67.765758,0 -14.35808,-35.35063 -14.35808,-35.3603 17.62128,-20.75934 17.5125,-20.75935 29.36879,0 c 32.631998,0 5.455822,5.28877 29.390108,7.16797 -3.81133,6.98972 7.16732,11.29772 7.16732,11.29772 l 2.51778,3.43975 c -1.74038,3.20932 -4.92039,6.69891 -9.3801,9.5709 l -3.2632,2.11064 -9.78959,-2.62144 c -8.593088,-2.27446 -11.312428,-2.61179 -22.080978,-2.61179 -13.0528,-0.0964 -14.35808,0.2506 -14.35808,4.29837 0,2.70817 3.15443,3.63336 12.72648,3.63336 21.42834,0 38.723308,8.01847 47.533928,22.10863 3.58951,5.73436 7.17904,15.86345 7.17904,20.50876 0,2.86236 4.45971,5.05973 7.50536,3.79721 2.82811,-1.09868 2.93687,-4.64531 0.65264,-14.01306 -2.28424,-9.36772 -7.83169,-17.88734 -15.77214,-24.29632 -5.32988,-4.30799 -6.30884,-5.49342 -5.11233,-6.24517 1.19649,-0.76135 2.06669,-0.51077 4.0246,1.08906 6.30885,5.23321 19.03534,7.00654 27.73719,3.88395 5.87377,-2.11064 11.85631,-7.17036 15.11951,-12.74088 1.52281,-2.53468 5.98253,-16.03694 9.89835,-29.9536 10.98611,-38.396111 22.08098,-72.320389 30.13021,-92.665317 5.54744,-14.176879 12.40016,-19.737762 23.16871,-18.812555 2.93688,0.250577 6.63517,1.175785 8.15801,2.023891 z m -126.72091,50.03831 c 2.28424,0.510792 5.76499,2.11063 7.72291,3.633367 5.87375,4.558576 6.20008,7.257098 3.80705,29.278954 -1.1965,10.71701 -1.94404,26.93071 -2.27035,27.1042 -0.32632,0.25057 -8.38942,-6.50868 -17.41761,-6.25812 l -16.533538,0.42407 0.65264,-6.66922 c 0.32632,-3.62372 1.19651,-13.83956 1.84915,-22.619385 0.65264,-9.19425 1.74037,-17.125977 2.50179,-18.561977 3.2632,-5.907835 10.550998,-8.269041 19.687958,-6.331889 z m 48.5129,9.454465 c 2.06668,1.011946 4.56848,3.209314 5.54744,4.89589 1.84914,2.871998 1.84914,4.22126 -0.8702,33.750816 -1.52282,17.04886 -3.37196,32.575 -4.24216,35.02295 -3.15442,8.51961 -9.13695,13.07819 -18.16513,13.67573 -4.78601,0.25056 -6.41762,0 -9.46327,-1.69622 -5.87376,-3.12256 -6.41764,-4.29838 -2.93689,-7.42094 6.20008,-5.744 4.00097,-11.09854 1.92352,-15.89687 0,0 -0.33391,-1.79223 -2.65798,-4.24016 l -2.01123,-1.92782 3.94219,-26.79768 c 1.95792,-22.869967 2.17547,-23.795174 5.11237,-26.667174 4.89478,-4.89589 16.96861,-6.24515 23.82134,-2.698522 z" />
              <rect style="fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:4.80000019;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4169" width="68.005806" height="55.413109" x="62.964886" y="157.3824"/>
              <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:1.60000002;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4170" width="39.957146" height="46.691494" x="105.05587" y="172.33051"/>
              <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4172" width="134.35677" height="7.9790406" x="49.16119" y="238.93228"/>
              <text xml:space="preserve" style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:184.28874207px;line-height:125%;font-family:'Arial Rounded MT Bold';-inkscape-font-specification:'Arial Rounded MT Bold, Normal';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#0000ff;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" x="6.6644416" y="260.41125" id="text4161" transform="scale(1.041834,0.95984582)"><tspan id="tspan4163" x="6.6644416" y="260.41125">C</tspan></text>
              <text xml:space="preserve" style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:28.53204727px;line-height:125%;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#ff0000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" x="90" y="175.07523" id="text4165" transform="scale(0.90874022,1.1004245)"><tspan id="tspan4167" x="90" y="175.07523">opious</tspan></text>
            </svg>
        </a>
        <div style="height:38;display:inline-block">
          <span class="user-name"  >$$USER_IDENTIFIER</span>
          <button class="help_getter" style="background-color:rgb(245, 255, 236);font-weight: bolder;font-size: larger;box-shadow: lightgoldenrodyellow;border-radius: 50%;">?</button>
          <!-- save in a place easy to see -->
          <button id="save-everything" onclick="save_everything(event)">save everything</button>
        </div>
      </div>
      <input id="all_tabs" type="hidden" value="" >
      <input id="window_tabs" type="hidden" value="" >
    </div>
    <div style="background-color: rgb(53, 10, 155);padding: 4px;border: 1px solid rgb(9, 32, 82)" >
      <span class="saver-help">Any edit activity (including delete) will be saved on the 
        server only after clicking a button requesting <span style="color:rgb(105, 241, 173);font-weight: bolder;font-size: 1.02em;" >SAVE</span></span>
        <input type="hidden" name="uemail" id="uemail" value="$$USER_IDENTIFIER" />
    </div>
  </div>

   <!-- Tab links -->
  <div class="tab">
    <button id="pick-ulisted_tabs" class="tablinks active" >View</button>
    <button id="pick-edit_clusters" class="tablinks" >Edit Clustering</button>
    <button id="pick-edit_topics" class="tablinks" >Edit Topics</button>
    <button id="pick-edit_words" class="tablinks" >Edit Words</button>
    <button id="pick-edit_domains" class="tablinks" >Edit Domains</button>
    <button id="pick-edit_windows" class="tablinks" >Edit Windows</button>
    <button id="pick-trash" class="tablinks" ondragover="event.preventDefault()" ondrop="handle_drop_link_trash(event)"  >&#128465;</button>
    <button id="pick-edit_help" class="tablinks" >Help</button>
  </div>

  <div id="ulisted_tabs" class="tabcontent" style="display: block;" >
      <h4>User Information</h4>
      <div style="max-width: 300px;">
        This page belongs to <span class="user-name">$$USER_IDENTIFIER</span>
      </div>
      <div style="grid-row: auto;height:160px;">
        <div id="user_list" class="tabcontent-sub" style="display:inline-block;height:150px;overflow:auto;width:25%" >

        </div>
        <div id="user_list" class="tabcontent-sub-tight" style="display:inline-block;height:150px;overflow:auto;width:5%;text-align: center;" >
          <div style="width: 100%;color:rgb(26, 36, 9);background-color:white;border-bottom: rgb(145, 99, 91) 2px solid;margin-bottom: 4px;" >
            display
          </div>
          <div class="display-button" onclick="front_view('topics')">topics</div>
          <div class="display-button" onclick="front_view('words')">words</div>
          <div class="display-button" onclick="front_view('domains')">domains</div>
          <div class="display-button" onclick="front_view('windows')">windows</div>
        </div>
        <div class="tabcontent-sub" id="linkcontent-sub" style="display:inline-block;height:150px;overflow:auto;width:60%" >

        </div>
      </div>

      <div  class="tabcontent-sub" style="height:300px;overflow:auto" >
        <b>List on display:</b> <span id="user-info-id"> </span>
        <div style = "border-bottom:darkslateblue 1px solid"> 
          <button onclick="unsort_list(true)">by priority</button>
          <button onclick="sort_list(true)">sort up</button>
          <button onclick="sort_list(false)">sort down</button>
          <button onclick="toggle_grid()">toggle grid</button>
        </div>
        <div id="user-data" class="tabcontent-sub" style="height:300px;overflow:auto" >
        </div>
      </div>
  </div>


  <div id="edit_clusters" class="tabcontent" >
    <h4>List of Stored Topics</h4> 
    <div style="max-width: 300px">Edit your top five key words. Then, click 
      <button class="cluster" onclick="save_with_cluster(event)">cluster</button> to update your topics</div>
      <div class="tabcontent-sub" style="display:inline-block;height:150px;overflow:auto;width:25%" >
        <ol id="user_clusters">
          <li>
            <input id="uc_1" type="text" value = "" />
          </li>
          <li>
            <input id="uc_2" type="text" value = "" />
          </li>
          <li>
            <input id="uc_3" type="text" value = "" />
          </li>
          <li>
            <input id="uc_4" type="text" value = "" />
          </li>
          <li>
            <input id="uc_5" type="text" value = "" />
          </li>
        </ol>
    </div>
    <div class="tabcontent-sub" style="display:inline-block;height:150px;overflow:auto;width:25%" >
      <div style="text-align: center;font-weight: bold;color:green;border-bottom: 1px solid rgb(2, 46, 46);">Manage Clustering and Classification</div>
      <div style="text-align: right;font-weight: bold;color:green;border-bottom: 1px solid rgb(2, 46, 46);"><button onclick="save_clustering_selection(event)">confirm selection</button></div>
      <select id="select-ml-options"  name="choose_ml" >

      </select>
    </div>
  </div>



  <div id="edit_topics" class="tabcontent" >
    <h4>Edit Topics</h4>
    <h6>add/delete topics, Move URLs, Delete URLS, Add URLS (by hand/copy/paste)</h6>
    <div>
      <button class="wsaver" onclick="fetch_user_topics('$$USER_IDENTIFIER')" >topics</button> 
      <button onclick="delete_from('topics')" >delete selected</button><button onclick="add_to('topics','topic-entry')">add</button><input id="topic-entry" type="text" >
      <button id="save-topics" onclick="save_all('topics')">save topic changes</button>
    </div>
    <div class="edit-ops-container">
      <div id="edit-left-topics" class="edit-left" >
left
      </div>
      <div id="edit-center-topics" class="edit-center" >
        <div class="edit-center-content-wrapper">
          topics
          <div id="topics-grid-topics" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          words
          <div id="words-grid-topics" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          domains
          <div id="domains-grid-topics" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          windows
          <div id="windows-grid-topics" class="edit-center-content" >
          </div>
        </div>
      </div>
      <div id="edit-right-topics" class="edit-right" >
check boxes on the left and then click <b>show links</b>
      </div>
    </div>
  </div>

  <div id="edit_domains" class="tabcontent" >
    <h4>Edit Domains</h4>
    <h6>Changes apply to the domain list and do not propagate to topics or words</h6>
    <div id="domain-app" >
      <button class="wulist" onclick="fetch_user_domains('$$USER_IDENTIFIER')">domains</button> 
      <button onclick="delete_from('domains')" >delete selected</button>
      <button onclick="add_to('domains','domain-entry')" >add</button><input id="domain-entry" type="text" >
      <button id="save-domains" onclick="save_all('domains')">save domain changes</button>
    </div>

    <div class="edit-ops-container">
      <div id="edit-left-domains" class="edit-left" >
left
      </div>
      <div id="edit-center-domains" class="edit-center" >
        <div class="edit-center-content-wrapper">
          topics
          <div id="topics-grid-domains" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          words
          <div id="words-grid-domains" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          domains
          <div id="domains-grid-domains" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          windows
          <div id="windows-grid-domains" class="edit-center-content" >
          </div>
        </div>
      </div>
      <div id="edit-right-domains" class="edit-right" >
        check boxes on the left and then click <b>show links</b>
      </div>
    </div>

  </div>
 
 
  <div id="edit_words" class="tabcontent" >
    <h4>Edit Word Lists</h4>
    <h6>Changes apply to the word list and do not propagate to topics or domains</h6>
    <div id="word-app" >
      <button class="wulist" onclick="fetch_user_words('$$USER_IDENTIFIER')" >words</button> 
      <button onclick="delete_from('words')" >delete selected</button>
      <button onclick="add_to('words','word-entry')" >add</button><input id="word-entry" type="text" >
      <button id="save-words"  onclick="save_all('words')">save word changes</button>
    </div>

    <div class="edit-ops-container">
      <div id="edit-left-words" class="edit-left" >
left
      </div>
      <div id="edit-center-words" class="edit-center" >
        <div class="edit-center-content-wrapper">
          topics
          <div id="topics-grid-words" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          words
          <div id="words-grid-words" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          domains
          <div id="domains-grid-words" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          windows
          <div id="windows-grid-words" class="edit-center-content" >
          </div>
        </div>
      </div>
      <div id="edit-right-words" class="edit-right" >
        check boxes on the left and then click <b>show links</b>
      </div>
    </div>

  </div>
 
  <div id="edit_windows" class="tabcontent" >
    <h4>Edit Window Lists</h4>
    <h6>Operate on the list of windows proper - windows removed may still be available in the topic list</h6>
    <div id="word-app" >
      <button class="wgetter" onclick="fetch_user_windows('$$USER_IDENTIFIER')">windows</button> 
      <button onclick="delete_from('windows')" >delete selected</button>
      <button onclick="add_to('windows','window-entry')" >add</button><input id="window-entry" type="text" >
      <button id="save-windows" onclick="save_all('windows')">save window changes</button>
    </div>
    <div class="edit-ops-container">
      <div id="edit-left-windows" class="edit-left" >
left
      </div>
      <div id="edit-center-windows" class="edit-center" >
        <div class="edit-center-content-wrapper">
          topics
          <div id="topics-grid-windows" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          words
          <div id="words-grid-windows" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          domains
          <div id="domains-grid-windows" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          windows
          <div id="windows-grid-windows" class="edit-center-content" >
          </div>
        </div>
      </div>
      <div id="edit-right-windows" class="edit-right" >
        check boxes on the left and then click <b>show links</b>
      </div>
    </div>
  </div>



  <div id="trash" class="tabcontent" >
    <h4>Discarded by Date</h4>
    <h6>Operate on the list of windows proper - windows removed may still be available in the topic list</h6>
    <div id="word-app" >
      <button onclick="delete_from('trash')" >delete selected</button>
    </div>
    <div class="edit-ops-container">
      <div id="edit-left-trash" class="edit-left" >
When you drag links to the trash can, a date entry will be made for this column.
Check the entry to see the urls. You can drag the urls out of the discard list and back to another active group.
      </div>
      <div id="edit-center-trash" class="edit-center" >
        <div class="edit-center-content-wrapper">
          topics
          <div id="topics-grid-trash" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          words
          <div id="words-grid-trash" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          domains
          <div id="domains-grid-trash" class="edit-center-content" >

          </div>  
        </div>
        <div class="edit-center-content-wrapper">
          windows
          <div id="windows-grid-trash" class="edit-center-content" >
          </div>
        </div>
      </div>
      <div id="edit-right-trash" class="edit-right" >
        check boxes on the left and then click <b>show links</b>
      </div>
    </div>
  </div>


  <div id="edit_help" class="tabcontent" style="background-color: rgb(253, 245, 229);cursor:pointer">
    <h4>How to use</h4> 
    <div id="help_display" style="max-width: 300px" style="background-color: inherit;color:rgb(133, 0, 0)">
      help goes here
    </div>
  </div>
 
 

  <div id="error-content" class="hidden">
    <p>Can't access the tab-senses tool from this web page.</p><p>Try a different page.</p>
  </div>

</body>

</html>
<script >
  // ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

// In the following line, you should include the prefixes of implementations you want to test.
window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
// DON'T use "var indexedDB = ..." if you're not in a function.
// Moreover, you may need references to some window.IDB* objects:
window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction || {READ_WRITE: "readwrite"}; // This line should only be needed if it is needed to support the object's constants for older browsers
window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
// (Mozilla has never prefixed these objects, so we don't need window.mozIDB*)



/*

// autoIncrement set to true  (for this special case DB use )

DB_VERSION
DATA_STORE
describe_data

*/


function warn(str) {
    //
}


// a session is a project...
// a session object (sessionObject) is stored in the DB and may contain parts of data
// part_id identifies a part of the data (e.g. a layer or a component)

class AppDBWrapper {

    constructor(name,conf) {
        this._can_process_db = true
        if ( !(window.indexedDB) ) {
            this._can_process_db = false
            console.log("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.");
        }
        //
        let self = this
        // DATA_STORE
        // DB_VERSION
        // describe_data
        if ( conf ) {
            for ( let ky in conf ) {
                self[ky] = conf[ky]
            }    
        }
        //
        this.db = false
        this.current_session_name = 'none'
        this._session_name_list = []
        this.name = name
        //
    }


    set session_name(name) {
        this.current_session_name = name
    }

    get session_name() {
        return this.current_session_name
    }

    get name_list() {
        return this._session_name_list
    }

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    init_database() {
        //
        if ( !(this._can_process_db) ) return false
        let self = this
        let db_name = this.name
        //
        let p = new Promise((resolve,reject) => {

            let request = window.indexedDB.open(db_name, this.DB_VERSION);
            //
            // <-- onerror
            request.onerror = (event) => {
                alert(`This web app will not store ${this.describe_data} without the use of computer storage.`)
            };
            
            // <-- onsuccess
            request.onsuccess = (event) => {
                //
                let db = event.target.result;
                db.onerror = (event) => {
                    console.log("Database error: " + event.target.error);
                    reject(event.target.error)
                };
                //
                self.db = db;
                resolve(db)
            }

            // <-- onupgradeneeded
            request.onupgradeneeded = (event) => {
                //
                let db = event.target.result;
                //
                try {
                    let sessionObjectStore = db.createObjectStore(this.DATA_STORE, { autoIncrement : true });
                    sessionObjectStore.createIndex("name", "name", { unique: true });
                    sessionObjectStore.createIndex("sess_date_time", "sess_date_time", { unique: true });
                } catch (e) {
                }
            //
            };
        })  // end of promise
        //
        return p
    }


    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    //      load_name_list
    // -- 
    load_name_list() {
        if ( !(this.db) ) return
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readonly");
        let dataStore = transaction ? transaction.objectStore(this.DATA_STORE) : false
        //
        if ( !(dataStore) ) return false
        let p = new Promise((resolve,reject) => {
            this._session_name_list = []
            let myIndex = dataStore.index('name');
            myIndex.openCursor().onsuccess = (event) => {
                let cursor = event.target.result;
                if ( cursor ) {
                    this._session_name_list.push(cursor.value.name)
                    cursor.continue();
                } else {
                    this.application_update_session_name_selections(this.current_session_name,this._session_name_list)
                    resolve(true)
                }
            }
        })
        //
        return p
    }

    // _apply_find_by_name
    //  -- a generic that calls success_callback when an element matches the index, or not_found_callback otherwise.
    //
    _apply_find_by_name(sess_name, store, success_callback, not_found_callback) {
        let nameIndex = store.index('name');
        nameIndex.get(sess_name).onsuccess = (evt) => {
            let value = evt.target.result;
            if ( value ) {
                if ( success_callback ) success_callback(value,nameIndex);
            } else {
                if ( not_found_callback ) not_found_callback();
            }
        };
    }

    // _add_session_to_db
    //  -- adds the session object to the db, sets up the basic fields... 
    //
    _add_session_to_db(dataStore,application_op,part_id) {
        //
        let sessionObj = {
            'name' : this.current_session_name,
            'sess_date_time' : '' + Date.now(),
            'data' : { },
            'hashes' : { },
            'edit_order' : []
        }
        //
        if ( part_id ) sessionObj.edit_order.push(part_id)
        //
        if ( (application_op !== undefined) && (typeof application_op === 'function') ) {
            application_op(sessionObj)
        }
        let request = dataStore.add(sessionObj);
        return request
    }
  

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    // add_data -- 
    //  Parameters: blob_data -- data stored as part of the session
    //              session id could be a layer....
    add_data(blob_data,part_id) {
        if ( !(this._can_process_db) ) return false
        if ( !(this.db) ) {
          console.log(`db not initialized :: AppDBWrapper.add_data`)
          return;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false

        let p = new Promise((resolve,reject) => {
            let self = this
            // update_list_callback
            let update_list_callback = (value,dbIndex) => {     // if found update
                if ( !dbIndex || (typeof value === "undefined") ) {
                    resolve(false)
                    return;
                }
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        // existing session 
                        let sessionObj = cursor.value
                        //
                        let blob_url = (typeof blob_data === 'string') ? blob_data : URL.createObjectURL(blob_data);
                        // map_id = part_id
                        // store revised data
                        sessionObj.data[part_id] = blob_data
                        // make sure the structure has been set up if not already
                        if ( sessionObj.hashes[part_id] === undefined ) {
                            sessionObj.hashes[part_id] = {}
                        }
                        if ( sessionObj.hashes[part_id].op_history === undefined ) {
                            sessionObj.hashes[part_id].op_history = []
                        }
                        // record the order in which sessions (layers) have been edited
                        sessionObj.edit_order.push(part_id)
                        //
                        // update IndexedDB
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            try {
                                self.application_data_update(blob_url,part_id,blob_data)  // application handling of data e.g visual rep
                            } catch (e) {
                                console.log(e)
                            } finally {
                                resolve(true)
                            }
                        };

                        request.onerror = (event) => {
                            resolve(false)
                        }
                        //
                    } else {
                        resolve(false)
                    }
                }
            }
            // add_new_callback
            let add_new_callback = () => {          // if not found add a new one
                //
                let blob_url = (typeof blob_data === 'string') ? blob_data : URL.createObjectURL(blob_data);
                //
                let application_op = (sessionObj) => {
                    //
                    sessionObj.data[part_id] = blob_data
                    if ( sessionObj.hashes[part_id] === undefined ) {
                        sessionObj.hashes[part_id] = {}
                    }
                    sessionObj.hashes[part_id].op_history = []
                    //
                } 
                //
                let request = self._add_session_to_db(dataStore,application_op,part_id)
                if ( request ) {
                    request.onsuccess = (event) => {
                        self.application_data_update(blob_url,part_id,blob_data)  // application handling of data e.g visual rep
                        resolve(true)
                    };
                    request.onerror = (event) => {
                        resolve(false)
                    }
                }
                //
            }
            //
            this._apply_find_by_name(this.current_session_name, dataStore, update_list_callback, add_new_callback)    
        })
        //
        return p
    }


    //  remove_data: 
    //      Parameters: part_id -- remove a sections of the data kept by the session named sess_name
    //                  sess_name -- A session or separate project or publication...
    //
    remove_data(part_id,sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //

        let p = new Promise((resolve,reject) => {
            // remove_from_list_callback
            let remove_from_list_callback = async (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        delete sessionObj.data[part_id]
                        //
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            //  item has been removed
                            console.log(`deleted ${part_id}`)
                            await this.app_secure_total_session(sess_name)
                            resolve(true)
                        };
                        //
                        request.onerror = (e) => {
                            resolve(false)
                        }
                    }
                    resolve(false)
                }
            }

            // not_found_callback 
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }

            this._apply_find_by_name(sess_name, dataStore, remove_from_list_callback, not_found_callback)
        })

        return p
    }
      
    //  remove_data: 
    //      Parameters: part_id -- remove a sections of the data kept by the session named sess_name
    //                  sess_name -- A session or separate project or publication...
    //
    get_data(part_id,sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //

        let p = new Promise((resolve,reject) => {
            // remove_from_list_callback
            let get_from_list_callback = async (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        let value =  sessionObj.data[part_id]
                        if ( value === undefined ) {
                            resolve(false)
                        } else {
                            resolve(value)
                        }
                    }
                    resolve(false)
                }
            }
        
            // not_found_callback 
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }
        
            this._apply_find_by_name(sess_name, dataStore, get_from_list_callback, not_found_callback)
        })

        return p
    }
      
 
    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    //  get_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //  Returns the object controlling all the data within the session.
    get_session(sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: get_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {
          //
          // get_elem_callback
          let get_elem_callback = (value,dbIndex) => {          // element.name == sess_name exists
            //
            let keyRangeValue = IDBKeyRange.only(value.name);
            //
            dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
              let cursor = event.target.result;
              if ( cursor ) {
                let sessionObj = cursor.value
                resolve(sessionObj)
              } else {
                reject(null)
              }
            }
          }
          //
          // not_found_callback
          let not_found_callback = () => {                       // element.name == sess_name  NOT FOUND
            reject(null)
          }
          //
          this._apply_find_by_name(sess_name, dataStore, get_elem_callback, not_found_callback)
        })
        //
        return p
    }

     
    //  delete_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //
    delete_session(sess_name) {
        //
        if ( !(this._can_process_db) ) return false

        if ( sess_name !== 'none ') {
            if ( this.db === null ) {
                console.log("db not initialized :: delete_session")
                return false;
            }
            //
            let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
            if ( !(transaction) ) return false
            let dataStore = transaction.objectStore(this.DATA_STORE);
            if ( !(dataStore) ) return false
        
            let p = new Promise((resolve,reject) => {
                // delete_from_list_callback
                let delete_from_list_callback = (value,dbIndex) => {
                    //
                    let keyRangeValue = IDBKeyRange.only(value.name);
                    //
                    dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                        let cursor = event.target.result;
                        if ( cursor ) {
                            let request = cursor.delete();
                            request.onsuccess = () => {
                                this.current_session_name = 'none'   /// here last
                                this.load_name_list()
                                this.application_revise_current_session(this.current_session_name)
                                resolve(true)
                            };
                        }
                        resolve(false)
                    }
                }
                //
                let not_found_callback = () => {
                    warn(`The session ${sess_name} is not in the database`)
                    resolve(false)
                }
                //
                this._apply_find_by_name(sess_name, dataStore, delete_from_list_callback, not_found_callback)    
            })
            //
            return p
        }
        return false
    }


    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    application_data_update(blob_url,part_id,blob_data) {
        // implemented by derived method (override)
    }

    async app_secure_total_session(sess_name) {
         // implemented by derived method (override)
    }

    application_revise_current_session(sess_name) {
        // implemented by derived method (override)
    }

    application_update_session_name_selections(sess_name,name_list) {

    }

}

</script>
<script>

const SERVER_PUT_TABS = "/put_tabs"
const SERVER_PUT_WINDOW = "/put_window"
const SERVER_DOMAIN_POST =  "/get_domains"
const SERVER_TOPICS_POST =  "/get_topics"
const SERVER_TOPIC_TABS_POST = "/get_topic_tabs"
const SERVER_TOPIC_LINKS_POST = "/get_link_package"
const SERVER_WINDOW_POST =  "/get_windows"
const SERVER_WINDOW_CLEAR =  "/clear"
const SERVER_WINDOW_UNDO =  "/undo"

// REAL STUFF
const USER_ADMIN_CMD =  "/user/$$USER_IDENTIFIER"

const DEFAULT_CLICK_CONTEXT = "domains"

let g_application_mail = false


let g_keep_data_around = {
  "windows" : "nada",
  "topics" : "nada",
  "domains" : "nada",
  "ulisted" : {
    "tab_list" : "nada",
    "window_tab_list" : "nada"
  }
}


let trashDB = false
async function db_startup() {
  trashDB = new AppDBWrapper("USER_TABS",{
    "DATA_STORE" : "TRASH",
    "DB_VERSION" : 2,
    "describe_data" : "$$USER_IDENTIFIER"
  })
  if ( trashDB ) {
    await trashDB.init_database()
    await initialize_trashy_display()
  }
}



// Generic method for querying the server ... temporary tab storage....
async function postData(url = '', data = {}, creds = 'omit', do_stringify = true, ctype) {
  let content_type = 'application/json'
  if ( ctype !== undefined ) {
      content_type = ctype
  }
  let options = {
      method: 'POST', // *GET, POST, PUT, DELETE, etc.
      mode: 'cors', // no-cors, *cors, same-origin
      cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
      credentials: creds, // include, *same-origin, omit
      headers: {
          'Content-Type': content_type
      },
      redirect: 'follow', // manual, *follow, error
      referrerPolicy: 'no-referrer', // no-referrer, *client
      body: (do_stringify ? JSON.stringify(data)  : data)	// body data type must match "Content-Type" header
  }

  if ( ctype === 'multipart/form-data') {
      delete options.headers['Content-Type']  // content type will be set automatically with a boundary
  }
  // Default options are marked with *
  const response = await fetch(url, options);
  if ( response.ok == false ) {
      console.log(response.status + ': ' + response.statusText)
      return {}
  } else {
    try {
      return await response.json(); // parses JSON response into native JavaScript objects
    } catch (e) {
      console.log(e)
      console.log(response)
      return({})
    }
  }
}



/**
 *  --  Just log the error to the console.
 */
function reportError(error) {
  console.error(`Could not come to my tab senses: ${error}`);
}




/// INTERACT WITH TABS AND TAB DB

//  logTabs 
//    -- --  display the tab information in a chosen list... 
function logTabs(tab_tables,tabs) {
  tab_tables.innerHTML = ""
  for (let tab of tabs) {
      let element = document.createElement('li')
      let h5 = document.createElement('h5')
      let dd = document.createElement('dd')
      //
      element.appendChild(h5)
      element.appendChild(dd)
      h5.innerHTML = tab.url
      dd.innerHTML = tab.title
      tab_tables.appendChild(element)
  }
}


function logList(a_tables,a_list,element_maker) {
  a_tables.innerHTML = ""
  for ( let el of a_list ) {
      let element = document.createElement('li')

      let content_el = element_maker ? element_maker(el) : false
      if ( !content_el ) {
        content_el = document.createElement('h5')
        element.appendChild(content_el)
        content_el.innerHTML = el
      }

      a_tables.appendChild(content_el)
  }
}




// ---- ---- ---- ---- ---- ---- ----
//
function insert_tabs(tab_data,tabs_stored,list_loc) {
  //
  g_keep_data_around.ulisted[list_loc] = tab_data
  //
  let message_spot = document.getElementById(list_loc)
  if ( message_spot !== undefined ) {
    //
    logTabs(message_spot,tab_data)
    //
  }

}


// ulist TABS TOGETHER... either all tabs in all windows
//                      or just tabs from the current window.


function tab_ulist(tabs,tabs_stored,list_loc) {
  //
  try {
    // // 
    let list = []
    for (let tab of tabs) {
      // tab.url requires the `tabs` permission
      list.push({"url" : tab.url, "title" : tab.title} );
    }
    // // 
    try {
      insert_tabs(list,tabs_stored,list_loc)
    } catch (ee) {
      console.log(ee)
    }
    //
  } catch (e) {
    console.log(e)
  }
}


// ---- ---- ---- ---- ---- ---- ----
//
async function do_op(op) {
  try {
    let email_in = document.getElementById('uemail')
    if ( email_in ) {
        let email = email_in.value
        if ( email.length ) {
            let postable = {
                "email" : email,
                "op" : op
            }
            try {
              let response = await postData(SERVER_TOPIC_TABS_POST + topic,postable)
              if ( response.OK === "true" ) {
                return
              }
            } catch (e) {
              alert(e)
            }
            return
        } else {
            alert("your account email is required")
        }
    }
  } catch(e) {
      alert(e)
  }
}





// // // // // // // // // // // // // // // // // // //
// // // // // // // // // // // // // // // // // // //



function logTopic(topic_tables,topics,without_filter,click_context) {

  g_keep_data_around[click_context] = topics

  topic_tables.innerHTML = ""
  for (let topic of topics) {   // these are links determined by the server; the links are to groups of tabs
    let tabs_finder = topic.link
    //
    if ( click_context === undefined ) {
      click_context = DEFAULT_CLICK_CONTEXT
    }
    //
    let element = document.createElement('li')
    let btn = document.createElement('button')
    btn.addEventListener('click',((tf) => {
        return((ev) => {
          fetch_topic(tf,without_filter)              // FETCH TOPIC fetch_topic, From a link to the server
        })
      })(tabs_finder))
    //
    let store_it = false
    if ( g_application_mail !== false && g_application_mail && g_application_mail.length ) {
        store_it = document.createElement('button')
        store_it.addEventListener('click',((tf) => {
          return(async (ev) => {
            let link_package = await fetch_topic_link_package(tf,click_context)              // FETCH TOPIC fetch_topic, From a link to the server
            if ( link_package ) {
              inject_topic_into_dashboard(tf,link_package)
            } else {
              console.log("no link package for ")
            }
          })
        })(tabs_finder))
      }
      //
      if ( store_it !== false && store_it ) {
        element.appendChild(store_it)
        store_it.innerHTML = "&#8595;"
      }

      if ( topic.count !== undefined ) {
        let counter = document.createElement('span')
        counter.className = "counter_box"
        counter.innerHTML = topic.count
        element.appendChild(counter)
      }

      element.appendChild(btn)
      btn.innerHTML = topic.descr
      topic_tables.appendChild(element)
    }
}


// retrieve the tabs that were stored given the email.
// There  are two possible post channels at the time of this writing... 
// One is for all tabs, the other is for a list of windows that were stored.
async function retrieve_tab_topics(post_channel,result_location,without_filter,context) {
  try {
    let email_in = document.getElementById('uemail')
    if ( email_in ) {
      let email = email_in.value
      email = (g_application_mail && g_application_mail.length )? g_application_mail : email
      if ( email.length  ) {
        let postable = {
            "email" : email
        }
        let response = await postData(post_channel,postable)
        if ( response.OK === "true" ) {
          let data = response.data
          let topic_spot = document.getElementById(result_location)
          if ( topic_spot ) {
            logTopic(topic_spot,data,without_filter,context)   // create buttons with links to groups of tabs
            return true
          }
        }
      } else {
          alert("your account email is required")
      }
    }
  } catch(e) {
      alert(e.message)
  }
  return false
}



// ---- ---- ---- ---- ---- ---- ---- ---- ---- ----




// STORE ... 
//

async function tab_field_saver(tab_field,post_action,opt_cluster_points) {
  //
  //let data_deposit = document.getElementById(tab_field)
  // let tab_info = data_deposit.value
  //
  let tabs_to_send = g_keep_data_around.ulisted[tab_field] 
  //
  if ( (tabs_to_send !== undefined) && tabs_to_send.length ) {
      try {
          let email_in = document.getElementById('uemail')
          if ( email_in ) {
              let email = email_in.value
              if ( email.length ) {
                  let postable = {
                      "email" : email,
                      "tabs" : tabs_to_send
                  }
                  if ( opt_cluster_points !== undefined ) {
                    postable.c_points = opt_cluster_points
                  }
                  let response = await postData(post_action,postable)
                  if ( response.OK === "true" ) {
                    let message_spot = document.getElementById("tab_list")
                    if ( message_spot ) {
                      let tab_data = [{
                        url : "tabs have been stored",
                        title : "log into your dashboard to organize your tabs at ...."
                      }]
                      logTabs(message_spot,tab_data)
                    }
                  }
                  return
              } else {
                  alert("your account email is required")
              }
          }
      } catch(e) {
          alert(e)
      }
  }

  alert("could not send data")
}





// FETCH
//  Fetch stored data.... 





// ---- ---- ---- ---- ---- ---- ----
//
async function fetch_topic(topic,without_filter) {
  try {
    let email_in = document.getElementById('uemail')
    if ( email_in ) {
        let email = email_in.value
        if ( email.length ) {
            let postable = {
                "email" : email
            }
            try {
              let response = await postData(SERVER_TOPIC_TABS_POST + topic,postable)
              if ( response.OK === "true" ) {
                  let data = response.data
                  //spawn_tabs(data,without_filter)       // given a group of tabs has been returned, open the tabs in the current window.
              }
            } catch (e) {
              alert(e)
            }
            return
        } else {
            alert("your account email is required")
        }
    }
  } catch(e) {
      alert(e)
  }
}


// ---- ---- ---- ---- ---- ---- ----
//
async function fetch_topic_link_package(topic,click_context) {
  try {
    let email_in = document.getElementById('uemail')
    if ( email_in ) {
        let email = email_in.value
        if ( email.length ) {
            let postable = {
                "email" : email,
                "sel_topic_domain" : click_context
            }
            try {
              let response = await postData(SERVER_TOPIC_LINKS_POST + topic,postable)
              if ( response.OK === "true" ) {
                  let data = response.data    // list of link packages
                  return(data)
              }
            } catch (e) {
              alert(e)
            }
            return
        } else {
            alert("your account email is required")
        }
    }
  } catch(e) {
      alert(e)
  }
  return(false)
}


// DISPLAY STYLING...
//
function openResults(currentTarget, tabName) {
  // Declare all variables
  let tabcontent, tablinks;
  // Get all elements with class="tabcontent" and hide them
  tabcontent = document.getElementsByClassName("tabcontent");
  tablinks = document.getElementsByClassName("tablinks");

  for (let i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }

  // Get all elements with class="tablinks" and remove the class "active"
  for ( let i = 0; i < tablinks.length; i++ ) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }

  g_current_source_context = (tabName === "trash") ? tabName : tabName.replace("edit_","")

  // Show the current tab, and add an "active" class to the button that opened the tab
  document.getElementById(tabName).style.display = "block";
  currentTarget.className += " active";
}


// USER INTERACTION...
//
function listenForClicks() {
  document.addEventListener("click", async (e) => {
    try {
      if (e.target.classList.contains("ulist")) {

      } else if ( e.target.classList.contains("getter") ) {

      } else if ( e.target.classList.contains("dgetter") ) {

      } else if ( e.target.classList.contains("saver") ) {

      } else if ( e.target.classList.contains("cluster") ) {

      } else if ( e.target.classList.contains("wulist") ) {

      } else if ( e.target.classList.contains("wsaver") ) {

      } else if ( e.target.classList.contains("wgetter") ) {

      } else if ( e.target.classList.contains("help_getter") || ( e.target.id === "pick-edit_help" )  ) {
        show_help()
        let target =  document.getElementById("pick-edit_help")
        openResults(target, "edit_help")
      } else if ( e.target.classList.contains("tablinks") ) {  // show what's there
        let id = e.target.id
        let tartget_name = (id.split('-'))[1]
        //
        openResults(e.currentTarget, tartget_name)
      } else if ( (e.target.id === "edit_help") ) {   // turn off help and look at something else
        let target =  document.getElementById("pick-ulisted_tabs")
        openResults(target, "ulisted_tabs")
      }
    } catch (err) {
        
    }

  });
}

/**
 * There was an error executing the script.
 * Display the popup's error message, and hide the normal UI.
 */
function reportExecuteScriptError(error) {
  document.querySelector("#popup-content").classList.add("hidden");
  document.querySelector("#error-content").classList.remove("hidden");
}


// ---- ---- ---- ---- ---- ---- ----
//
async function show_help() {

}


// ---- ---- ---- ---- ---- ---- ----
//
function hide_help() {
  let help_field = document.getElementById("help_display")
  if ( help_field ) {
    help_field.innerHTML = ""
  }
}

// ---- ---- ---- ---- ---- ---- ----
//
function initialize_dashboard() {
  //
  console.log("initiaize")

  //initialize_db()

  g_application_mail = false
  //

}


// ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
function inject_topic_into_dashboard(package_name,link_package) {
//
}



/// SAVE STUFF... ....



async function save_everything(ev) {

  console.log("save_everything::  ")

  let data_to_save = JSON.stringify(g_keep_data_around)
  let email = g_application_mail
  if ( email ) {
    let storage_record = {
      "command" : "update",
      "email" : email,
      "user_tabs" : {
        "email" : email,
        "data" : data_to_save
      }
    }
    //console.log("save_everything::  " + data_to_save)
    //
    // SAVE EVERYTHING
    //
  }

  for ( let category of ["topics", "words", "domains", "windows"] ) {
    await save_all(category)
  }

  dirty_edit_update(false)
}





/// CLUSTERING SAVE -- save_with_cluster
// ------ ------ ------ ------ ------ ------ ------ ------ ------


function get_cluster_point_list() {
  let points = []
  for ( let i = 0; i < 5; i++ ) {
    let c_val_holder = document.getElementById(`uc_${i+1}`)
    if ( c_val_holder ) {
      let term_point = c_val_holder.value
      term_point = term_point.trim()
      if ( term_point.length ) {
        points.push(term_point)
      }
    }
  }
  return (points.length ? points : undefined)
}


async function save_with_cluster(event) {
  let cluster_points = get_cluster_point_list()
  if ( cluster_points ) {
    await save_tabs(cluster_points)
  }
}


function fill_topic_dims(topic_dims) {
  let cluser_entry = "uc_"
  for ( let i = 0; i < topic_dims.length; i++ ) {
    let val = topic_dims[i]
    let val_loc = cluser_entry + i
    let val_el = document.getElementById(val_loc) 
    if ( val_loc ) {
      val_loc.value = val
    }
  }
}




async function save_tabs(cluster_points) {
  if ( cluster_points && cluster_points.length ) {
    await tab_field_saver('tab_list',SERVER_PUT_TABS,cluster_points)
  } else {
    await tab_field_saver('tab_list',SERVER_PUT_TABS)
  }
}

// ------ ------ ------ ------ ------ ------ ------ ------ ------
// ------ ------ ------ ------ ------ ------ ------ ------ ------



async function save_window() {
}


async function save_user_info(user,category,data,deleted) {
  let disp_drop = document.getElementById("user-data")
  if ( disp_drop ) {
    let postable = {
      "cmd" : `user-save-${category}`,
      "user" : user,
      "data" : data,
      "deleted" : deleted
    }
    let response = await postData(USER_ADMIN_CMD,postable)
    if ( response.OK !== "true" ) {
      console.log("oops")
    }
  }
}


async function save_clustering_selection(ev) {
  let disp_drop = document.getElementById("user-data")
  if ( disp_drop ) {
    let option_el = document.getElementById("select-ml-options")
    if ( option_el ) {
      let current_choice = option_el.value
      let postable = {
        "cmd" : `ml_nlu_select`,
        "user" : '$$USER_IDENTIFIER',
        "ml_nlu_select" : current_choice
      }
      let response = await postData(USER_ADMIN_CMD,postable)
      if ( response.OK !== "true" ) {
        console.log("oops")
      }
    }
  }
}


// message to the server to update the sets
// belonging to this user....
async function save_all(category) {
  //let [a_list,a_map] = get_edit_lists(category)
  let a_map = g_manage_delivered[category]
  let deleted = get_deleted(category)
  if ( a_map ) {
    await save_user_info('$$USER_IDENTIFIER',category,a_map,deleted)
    dirty_edit_update(false,category)
  }
}




/// DELETE --- Delete is just local editing... the user is requested to save state.








function load_previous(email) {
  if ( email !== false  ) {
    console.log("sending message")
  }
}

function initialize_db() {
  console.log("db initialize called")
}

/**
 * When the popup loads, inject a content script into the active tab,
 * and add a click handler.
 * If we couldn't inject the script, handle the error.
*/
listenForClicks()
initialize_dashboard()


function setup_key_event() {
  document.addEventListener("change",(ev) => {
    update_dash_link(ev)
  })
}

function update_dash_link(ev) {
  let email_src = ev.target
  if ( email_src && (email_src.id === "uemail") ) {
    let email = email_src.value
    //alert(email_src.id + " " + email)
    if ( email && email.length ) {
      let dash_link = document.getElementById("dashlink")
      if ( dash_link ) {
        dash_link.href = `/dashboard/${email}`
      }
    }
  }
}

setup_key_event()







function setup_display_clustering_options(sys_add_ml_possibilities,current_choice) {
  let option_el = document.getElementById("select-ml-options")
  if ( option_el ) {
    let opts_html = ""
    for ( let ml_opt in sys_add_ml_possibilities ) {
      opts_html += `<option>${ml_opt}</option>`
    }
    option_el.innerHTML = opts_html
    option_el.value = current_choice
  }
}



async function fetch_user_info(user) { // ---- ---- ---- ---- ---- ---- ---- ----
  let disp_drop = document.getElementById("user_list")
  if ( disp_drop ) {
    let postable = {
      "cmd" : "user-info",
      "user" : user
    }
    let response = await postData(USER_ADMIN_CMD,postable)
    if ( response.OK === "true" ) {
      let user = response.data
      let info_loc = document.getElementById("user_list")
      if ( info_loc ) {
        //
        let info = `email: ${user.email}&nbsp;&nbsp;&nbsp;&nbsp;blocked ?> ${user.blocked} Selected ML: ${user.ml_selector}<br>`
        info += `_word_list #: ${user._word_list_count}<br>`
        info += `_topics #: ${user._topics}<br>`
        info += `_domains #: ${user._domains_count}<br>`
        info += `_windows #: ${user._windows_count}<br>`
        info += `_all_topics #: ${user._all_topics_count}<br>`
        info += `_all_domains #: ${user._all_domains_count}<br>`
        info += `_topic_dims (${user._topic_dims.length}): ${user._topic_dims.join(',')}`
        //
        info_loc.innerHTML = info

        if ( user._topic_dims.length > 0 ) {
          fill_topic_dims(user._topic_dims)
        }

        if ( user._sys_add_ml_possibilities ) {
          setup_display_clustering_options(user._sys_add_ml_possibilities,user.ml_selector)
        }

      }
    }
  }

}


function push_if_new(to_list,value) {
  if ( to_list.indexOf(value) >= 0 ) {
    return false
  } else {
    to_list.push(value)
  }
  return true
}


// { "url" : url, "title" : title }
function set_if_new(to_map,tab_obj) {
  if ( to_map[tab_obj.url] === undefined ) {
    to_map[tab_obj.url] = tab_obj.title
    return true
  }
  return false
}



const DRAG_SEP = '|^!'

let g_grid_on = true
let g_last_sort_direction = "priority"

let g_current_source_context = "topics"


let g_last_shown_list = []  // the term proper (on use reference to the category saved below g_<cat>_list)
let g_last_shown_map = {}   // used in showing the sorted lists
let g_last_list_rendering = []   /// g_finally_display_<category>



// Will not op on words --- leave it up to ML 
// Topics subset Words  --- ops on topics get data from words,  e.g. descriptions and titles
// domains do not supply titles --- windows or words may --- maybe stored titles with domains....


let g_word_delivered = {}   // words exactly what came from the server
let g_topic_delivered = {}  // topics exactly what came from the server
let g_domain_delivered = {} // domains exactly what came from the server
let g_window_delivered = {} // windows exactly what came from the server

// list of terms (not objects -- just strings)
let g_word_list = [] // for making the edit displays
let g_topic_list = [] // for making the edit displays
let g_domain_list = [] // for making the edit displays
let g_window_list = [] // for making the edit displays

// maps that have been constructed on the server <term,descriptive object>
let g_word_map = {} // for making the edit displays
let g_topic_map = {} // for making the edit displays
let g_domain_map = {} // for making the edit displays
let g_window_map = {} // for making the edit displays

// These are the displays with hot buttons primed with the links from the display maps
// These are drawn on the user info screen as buttons. The buttons when clicked will provide clickable url's in 
// the url display regions (upper right)
let g_finally_display_words = []
let g_finally_display_topics = []
let g_finally_display_domains = []
let g_finally_display_windows = []

// these are the mapping key terms to hot button displays (array elements in finally display arrays (also last shown list))
// these correspond to last show map used in reconstructin the rendering 
// (front display) when sorting (or switching between verticle to rows)
let g_finally_display_words_map = {}
let g_finally_display_topics_map = {}
let g_finally_display_domains_map = {}
let g_finally_display_windows_map = {}

// handle the trash (discards of urls) ... Allow for a local record of url's that might be worth retrieving.
let g_trash_entries = {}
let g_deleted = {
  "topics" : [],
  "words" : [],
  "domains" : [],
  "windows" : []
}

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

let g_dirty_edits = {
  "topics" : {
    "prefix" : "save-",
    "el" : null,
    "state" : false,
    "on_style" : "border: darkred 2px solid",
    "off_style" : "",
    "propagate" : "everything",
    "back_propagate" : false
  },
  "words" : {
    "prefix" : "save-",
    "el" : null,
    "state" : false,
    "on_style" : "border: darkred 2px solid",
    "off_style" : "",
    "propagate" : "everything",
    "back_propagate" : false
  },
  "domains" : {
    "prefix" : "save-",
    "el" : null,
    "state" : false,
    "on_style" : "border: darkred 2px solid",
    "off_style" : "",
    "propagate" : "everything",
    "back_propagate" : false
  },
  "windows" : {
    "prefix" : "save-",
    "el" : null,
    "state" : false,
    "on_style" : "border: darkred 2px solid",
    "off_style" : "",
    "propagate" : "everything",
    "back_propagate" : false
  },
  "everything" : {
    "prefix" : "save-",
    "el" : null,
    "state" : false,
    "on_style" : "border: darkred 2px solid",
    "off_style" : "",
    "propagate" : false,
    "back_propagate" : ["topics", "words", "domains", "windows"]
  },
}


let g_manage_delivered = {
  "words" : g_word_delivered,
  "topics" : g_topic_delivered,
  "domains" : g_domain_delivered,
  "windows" :g_window_delivered
}

/// /// /// /// /// /// /// // // // // // //

function dirty_edit_update(state,category) {
  if ( state ) {
    let vardescr = g_dirty_edits[category]
    if ( vardescr === undefined ) return
    let el = vardescr.el
    el.style = vardescr.on_style
    //
    let propagate = vardescr.propagate
    if ( propagate ) {
      dirty_edit_update(true,propagate)  // simple fan in for just this page (not universal)
    }
  } else {
    let cat = (category === undefined)  ? "everything" : category
    let vardescr = g_dirty_edits[cat]
    let el = vardescr.el
    el.style = vardescr.off_style
    let bprops = vardescr.back_propagate
    if ( bprops ) {
      for ( let bprop of bprops ) {
        dirty_edit_update(false,bprop)
      }
    }
  }
}
// save-${category}
//save-everything


function prep_updates() {
  for ( let ky in g_dirty_edits ) {
    let vardescr = g_dirty_edits[ky]
    let el_id = vardescr.prefix + ky
    let el = document.getElementById(el_id)
    vardescr.el = el
    vardescr.state = false
  }
}



function get_deleted(category) {
  let dels = g_deleted[category]
  return dels
}


function insert_deleted(category,key) {
  let dels = g_deleted[category]
  if ( dels ) {
    if ( dels.indexOf(key) < 0 ) {
      dels.push(key)
    }
  }
}


function add_all_deletes(category,del_vals) {
  for ( let val of del_vals )  {
    insert_deleted(category,val)
  }
}


/// e.g. server side (from admin, via /user/:uid) 
///       _all_topics is g_manage_delivered["topics"]  -- all_topics[topic] -> {<url,title>} 
//
function change_save_state_move(url,title,source_context,dest_context,dest_holding_element,source_holding_element) {
  if ( dest_context ) {
    switch ( dest_context ) {
      case "topics":
      case "domains": {
        let c_data = g_manage_delivered[dest_context]
        if ( c_data[dest_holding_element] === undefined ) {
          c_data[dest_holding_element] = {}         /// maintain url,title pairing
        }
        c_data[dest_holding_element][url] = title
        break
      }
      case "words" : {
        let word_data = g_manage_delivered[dest_context]
        if ( word_data ) {
          let word_obj = word_data[dest_holding_element]
          if ( word_obj ) {
            let c_data = word_obj._url_list
            if ( c_data[url] === undefined ) {
              c_data[url] = title
            }
          }
        }
        break;
      }
      case "windows" : {
        let c_data_list = g_manage_delivered[dest_context]   // this should be an array
        if ( c_data_list ) {
          let c_data_entry = c_data_list.find((entry) => {
            if ( entry.descr ) {
              if ( entry.descr === dest_holding_element ) {
                return true
              }
            }
            return false
          })
          if ( c_data_entry ) {
            let c_data = c_data_entry.tabs.find((entry) => {
                                                if ( entry.url ) {
                                                  if ( entry.url === url ) {
                                                    return true
                                                  }
                                                }
                                                return false
                                              })
            if ( !c_data ) {
              c_data_entry.tabs.push({
                "url" : url,
                "title" : title
              })
            }
          }
        }

        break
      }
    }
  }
  if ( source_context ) {
    switch ( source_context ) {
      case "topics":
      case "domains": {
        let c_data = g_manage_delivered[source_context]
        if ( c_data[source_holding_element] !== undefined ) {
          delete c_data[source_holding_element][url]
        }
        break
      }
      case "words" : {
        let word_data = g_manage_delivered[source_context]
        if ( word_data ) {
          let word_obj = word_data[source_holding_element]
          if ( word_obj ) {
            let c_data = word_obj._url_list
            if ( c_data[url] !== undefined ) {
              delete c_data[url]
            }
          }
        }
        break;
      }
      case "windows" : {
        let c_data_list = g_manage_delivered[source_context]   // this should be an array
        if ( c_data_list ) {
          let c_data_entry = c_data_list.find((entry) => {
                                                  if ( entry.descr ) {
                                                    if ( entry.descr === source_holding_element ) {
                                                      return true
                                                    }
                                                  }
                                                  return false
                                                })
          if ( c_data_entry ) {
            let c_data_index = c_data_entry.tabs.findIndex((entry) => {
                                                if ( entry.url ) {
                                                  if ( entry.url === url ) {
                                                    return true
                                                  }
                                                }
                                                return false
                                              })
            if ( c_data_index >= 0 ) {
              c_data_entry.tabs.splice(c_data_index,1)
            }
          }                                            
          break;
        }
      }
    }
  }
}


// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----


function install_editing(a_list,container_id,btype) {
  let container = document.getElementById(container_id)
  if ( container ) {
    let list_edit_table = a_list.map((a_entry) => {
      //
      let control = `<label for="${a_entry}-id">${a_entry}</label><input type="checkbox" id="${a_entry}-id" name="op_list_${btype}" value="${a_entry}" onchange="show_links('${btype}')">` 
      //
      return control
    })
    let display = list_edit_table.join("<br>")
    container.innerHTML = display
  }
}

function info_grid(info) {
  let display_column = []
  let input = [].concat(info)
  while ( input.length ) {
    let row = input.splice(0,11)
    display_column.push(row.join('&nbsp;'))
  }
  let output = display_column.join("</div><div class='word-divs'>")
  output = "<div class='word-divs'>" + output + "</div>"
  return output
}


function finally_display(info) {
  g_last_list_rendering = info
  let info_loc = document.getElementById("user-data")
  if ( info_loc ) {
    if ( !g_grid_on ) {
      info_loc.innerHTML = info.join("<br>")
    } else {
      info_loc.innerHTML = info_grid(info)
    }
  }  
}

function toggle_grid() {
  g_grid_on = !g_grid_on
  finally_display(g_last_list_rendering)
}


function sort_list(dir_up) {
  g_last_sort_direction = dir_up
  //
  let url_array = [].concat(g_last_shown_list)
  if ( dir_up ) {
    url_array.sort()
  } else {
    url_array.sort((a,b) => {
      if ( a == b ) return 0
      if ( a < b ) return 1
      if ( a > b ) return -1
    })
  }
  let info = url_array.map(dom => {
    return g_last_shown_map[dom]
  })
  finally_display(info)
}


function unsort_list() {
  g_last_sort_direction = "priority"
  //
  let url_array = [].concat(g_last_shown_list)
  let info = url_array.map(dom => {
    return g_last_shown_map[dom]
  })
  finally_display(info)
}


// ---- ---- ---- ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ---- ---- ---- ----

// BUTTON RESPONSE FOR SHOWING ENTRY CONTENT
function show_domain_links(doml_str) {
  let link_spot = document.getElementById("linkcontent-sub")
  if ( link_spot ) {
    let url_array = doml_str.split(',')
    url_array = url_array.map(url => {
      return `<a href="${url}" target="TABS-COPIOUS-RETRIEVE">${url}</a>`
    })
    url_array = url_array.join("<br>")
    link_spot.innerHTML = url_array
  }
}


function show_word_links(doml_str) {
  let link_spot = document.getElementById("linkcontent-sub")
  if ( link_spot ) {
    let url_array = doml_str.split(',')
    url_array = url_array.map(url => {
      return `<a href="${url}" target="TABS-COPIOUS-RETRIEVE">${url}</a>`
    })
    url_array = url_array.join("<br>")
    link_spot.innerHTML = url_array
  }
}

function show_window_links(doml_str) {
  let link_spot = document.getElementById("linkcontent-sub")
  if ( link_spot ) {
    let url_array = doml_str.split(',')
    url_array = url_array.map(url => {
      return `<a href="${url}" target="TABS-COPIOUS-RETRIEVE">${url}</a>`
    })
    url_array = url_array.join("<br>")
    link_spot.innerHTML = url_array
  }
}

// NEW DATA DISPLAY
function display_info_list(u_info) {
  let info = Object.keys(u_info)
  //
  g_last_shown_list = [].concat(info)
  //
  info = info.map(dom => {
    let links = ""
    if ( Array.isArray(u_info[dom]) ) {
      links = u_info[dom]
    } else {
      links = Object.keys(u_info[dom])      
    }
    let dom_links = links.join(',')
    console.log(dom_links)
    return `<button onclick="show_domain_links('${dom_links}')">${dom}</button>`
  })
  //
  g_last_shown_map = {}
  for ( let i = 0; i < info.length; i++ ) {
    g_last_shown_map[g_last_shown_list[i]] = info[i]
  }
  //
  finally_display(info)
  //
  let list_choice = document.getElementById("user-info-id")
  if ( list_choice ) {
    list_choice.innerHTML = "domains"
  }
  //
  return [[].concat(g_last_shown_list),Object.assign({},u_info),info,g_last_shown_map]
}

function display_word_list(u_info) {
  let info = Object.keys(u_info)
  info = info.filter(word => { return word[0] != '_' })
  //
  g_last_shown_list = [].concat(info)
  //
  let word_map = {}
  info = info.map(word => {
    let infow = u_info[word]
    if ( infow._url_list ) {
      let word_links = Object.keys(u_info[word]._url_list)   // these are <url,descr pairs>
      word_map[word] = word_links
      word_links = word_links.join(',')
      return `<button onclick="show_domain_links('${word_links}')">${word}</button>`
    } else {
      return ""
    }
  })
  //
  g_last_shown_map = {}
  for ( let i = 0; i < info.length; i++ ) {
    g_last_shown_map[g_last_shown_list[i]] = info[i]
  }
  //
  finally_display(info)
  //
  let list_choice = document.getElementById("user-info-id")
  if ( list_choice ) {
    list_choice.innerHTML = "words"
  }

  return [[].concat(g_last_shown_list),word_map,info,g_last_shown_map]
}

/*
let g_window_delivered = {} // windows exactly what came from the server
*/

function _place_windows(u_info) {
  g_last_shown_list = []
  g_window_map = {}
  let info = u_info.map(window_descr => {    // map on array
    let wtabs = window_descr.tabs
    if ( wtabs ) {
      wtabs = wtabs.map((ldescr) => {
        let link = ldescr.url       // these are <url,descr> pairs
        return link
      })
      g_window_map[window_descr.descr] = wtabs
      let dom_links = wtabs.join(',')
      g_last_shown_list.push(window_descr.descr)
      return `<button onclick="show_window_links('${dom_links}')">${window_descr.descr}</button>`
    }
  })
  g_window_list = [].concat(g_last_shown_list)
  // PUT DATA INTO THE DIPSPLAY MAP
  g_last_shown_map = {}
  for ( let i = 0; i < info.length; i++ ) {
    g_last_shown_map[g_last_shown_list[i]] = info[i]
  }
  g_finally_display_windows = info
  g_finally_display_windows_map = g_finally_display_windows
  //
  finally_display(info)
  //
  let list_choice = document.getElementById("user-info-id")
  if ( list_choice ) {
    list_choice.innerHTML = "windows"
  }
  //
  install_editing(g_window_list,"edit-left-windows","windows")
  show_links("windows")
  //
}


// WINDOW DATA SHAPE IS DIFFERENT 
async function fetch_user_windows(user) {
  let disp_drop = document.getElementById("user-data")
  if ( disp_drop ) {
    let postable = {
      "cmd" : "user-windows",
      "user" : user
    }
    let response = await postData(USER_ADMIN_CMD,postable)
    if ( response.OK === "true" ) {
      g_window_delivered = response.data
      g_manage_delivered["windows"] = g_window_delivered
      _place_windows(g_window_delivered)
    }
  }
}


/*
let g_domain_delivered = {} // domains exactly what came from the server
*/

function _place_domains(data) {
  let [a_list, a_map, front_display,front_map] = display_info_list(data)
  g_domain_list = a_list
  g_domain_map = a_map
  g_finally_display_domains = front_display
  g_finally_display_domains_map = front_map
  install_editing(g_domain_list,"edit-left-domains","domains")
  show_links("domains")
}


// API LEVEL CALLS
async function fetch_user_domains(user) {
  let disp_drop = document.getElementById("user-data")
  if ( disp_drop ) {
    let postable = {
      "cmd" : "user-domains",
      "user" : user
    }
    let response = await postData(USER_ADMIN_CMD,postable)
    if ( response.OK === "true" ) {
      g_domain_delivered = response.data
      g_manage_delivered["domains"] = g_domain_delivered
      _place_domains(g_domain_delivered)
    }
  }
}

/*
let g_word_map = {} // for making the edit displays
let g_topic_map = {} // for making the edit displays
let g_domain_map = {} // for making the edit displays
let g_window_map = {} // for making the edit displays
*/

/*
let g_topic_delivered = {}  // topics exactly what came from the server
*/


function _place_topics(data) {
  let [a_list, a_map, front_display,front_map] = display_info_list(data)
  g_topic_list = a_list
  g_topic_map = a_map
  g_finally_display_topics = front_display
  g_finally_display_topics_map = front_map
  install_editing(g_topic_list,"edit-left-topics","topics")
  show_links("topics")
}


async function fetch_user_topics(user) {
  let disp_drop = document.getElementById("user-data")
  if ( disp_drop ) {
    let postable = {
      "cmd" : "user-topics",
      "user" : user
    }
    let response = await postData(USER_ADMIN_CMD,postable)
    if ( response.OK === "true" ) {
      g_topic_delivered = response.data
      g_manage_delivered["topics"] = g_topic_delivered
      _place_topics(g_topic_delivered)
    }
  }
}

/*
let g_word_delivered = {}   // words exactly what came from the server
*/


function _place_words(data) {
  let [a_list, a_map, front_display,front_map] = display_word_list(data)
  g_word_list = a_list
  g_word_map = a_map
  g_finally_display_words = front_display
  g_finally_display_words_map = front_map
  install_editing(g_word_list,"edit-left-words","words")
  show_links("words")
}


async function fetch_user_words(user) {
  let disp_drop = document.getElementById("user-data")
  if ( disp_drop ) {
    let postable = {
      "cmd" : "user-words",
      "user" : user
    }
    let response = await postData(USER_ADMIN_CMD,postable)
    if ( response.OK === "true" ) {
      g_word_delivered = response.data
      g_manage_delivered["words"] = g_word_delivered
      _place_words(g_word_delivered)
    }
  }
}


// // //
// // // // // 
async function fetch_all() {
  await fetch_user_info("$$USER_IDENTIFIER")
  await fetch_user_topics('$$USER_IDENTIFIER')
  await fetch_user_domains('$$USER_IDENTIFIER')
  await fetch_user_words('$$USER_IDENTIFIER')
  await fetch_user_windows('$$USER_IDENTIFIER')
}



function get_edit_lists(which_list) {
  let a_list = g_topic_list
  let a_map = g_topic_map
  switch ( which_list ) {
    case "topics" : {
      a_list = g_topic_list
      a_map = g_topic_map
      break
    }
    case "domains" : {
      a_list = g_domain_list
      a_map = g_domain_map
      break
    }
    case "words" : {
      a_list = g_word_list
      a_map = g_word_map
      break
    }
    case "windows" : {
      a_list = g_window_list
      a_map = g_window_map
      break
    }
    case "trash" : {
      a_list = Object.keys(g_trash_entries)
      a_map = g_trash_entries
      break
    }
  }
  return [a_list,a_map]
}


function show_moveable_links(which_list) {

  let container = document.getElementById("edit-right-" + which_list)
  if ( container ) {
    let name = `op_list_${which_list}`
    let checkedBoxes = document.querySelectorAll(`input[name=${name}]:checked`);

    let len = checkedBoxes.length
    let sel_vals = []
    for ( let i = 0; i < len; i++ ) {
      let bx = checkedBoxes[i]
      sel_vals.push(bx.value)
    }

    let [a_list,a_map] = get_edit_lists(which_list)

    let display_links = sel_vals.map(value => {
      let disp_links = a_map[value]
      let links = ""
      if ( !(Array.isArray(disp_links)) && (typeof disp_links === "object") ) {
        disp_links = Object.keys(disp_links)
      }
      if ( disp_links && disp_links.length ) {
        disp_links = disp_links.map(a_link => {
          return `<span class="drag_link" draggable="true" style="border-bottom:solid 1px snow;margin-bottom:1px;"  ondragstart="event.dataTransfer.setData('text/plain','${value}${DRAG_SEP}${a_link}')">${a_link}</span>`
        })
        links = disp_links.join("<br>")
      }
      let display_template = `
    <div  style="border: 1px solid navy; padding 2px;">
      <div  style="border-bottom: 1px solid darkgreen; margin-bottom:2px; font-weight:bolder; color: darkgreen">${value}</div>
      <div style="background-color:rgba(200,248,248,0.6);color:darkpurple;">
        ${links}
      </div>
    </div>
`
      return display_template
    })
  
    container.innerHTML = display_links.join("\n")

  }
}

// gets value from checkboxes 
function show_drop_operators(which_list,context) {
  //
  let container = document.getElementById(`${which_list}-grid-${context}`)
  if ( container ) {
    let name = `op_list_${which_list}`
    let checkedBoxes = document.querySelectorAll(`input[name=${name}]:checked`);

    let len = checkedBoxes.length
    let sel_vals = []
    for ( let i = 0; i < len; i++ ) {
      let bx = checkedBoxes[i]
      sel_vals.push(bx.value)
    }

    let display_links = sel_vals.map(value => {
      //
      let display_template = `
    <div  class="edit-center-dropper" ondragover="event.preventDefault()" ondrop="handle_drop_link(event,'${context}','${which_list}','${value}')" >
      ${value}
    </div>
`
      return display_template
    })
  
    container.innerHTML = display_links.join("\n")
  }
  //
}


function get_url_map_key(str) {
  let seploc = str.indexOf(DRAG_SEP)
  if ( seploc > 0  ) {
    let [from_key,url] = str.split(DRAG_SEP,2)
    return [from_key,url]
  }
  return [false,false]
}



function title_from_context(url,from_key,from_map,source_context) {
  //
  switch ( source_context ) {
    case "topics" :
    case "domains" : {
      let source_obj = from_map[from_key]
      return source_obj[url]
      break
    }
    case "words" : {
      let words = g_manage_delivered["words"]
      let wobj = words[from_key]
      if ( wobj ) {
        let source_obj = wobj._url_list
        if ( source_obj ) {
          return source_obj[url]
        }
      }
      break
    }
    case "windows" : {
      let windows = g_manage_delivered[source_context]
      let a_window = windows.find((w) => {
        if ( from_key === w.descr ) {
          return true
        }
        return false
      })
      if ( a_window ) {
        let tabs = a_window.tabs
        let tab_obj = tabs.find(tab => {
          return tab.url === url
        })
        if ( tab_obj ) return tab_obj.title
      }
      break
    }
  }
  return "test"
}



function handle_drop_link(event,source_context,dest_context,element) {
  //
  event.preventDefault();
  //
  if ( event.dataTransfer ) {
    const data = event.dataTransfer.getData("text/plain");
    let [from_key,url] = get_url_map_key(data)
    if ( from_key ) {
      //  DISPLAY LIST CHANGES
      let [a_to_list,to_map] = get_edit_lists(dest_context)
      let [a_from_list,from_map] = get_edit_lists(source_context)
      //
      let title = title_from_context(url,from_key,from_map,source_context)      // always keep titles with the URL...
      //
      let to_list = to_map[element]
      let from_list = from_map[from_key]
      //
      if ( !(event.altKey) ) {
        if ( Array.isArray(from_list) ) {
          let idx = from_list.indexOf(url)
          if ( idx >= 0 ) {
            from_list.splice(idx,1)
          }
        } else {
          if ( from_list[url] ) delete from_list[url]
        }
      }
//
      if ( Array.isArray(to_list) ) {
        if ( push_if_new(to_list, url) ) {
          dirty_edit_update(true,dest_context)
        }
      } else {
        if ( set_if_new(to_list, { "url" : url, "title" : title }) ) {
          dirty_edit_update(true,dest_context)
        }
      }
      //
      show_links(dest_context)
      show_links(source_context)
      //
      if ( event.altKey ) source_context = "DONT"   /// don't change the source 
      change_save_state_move(url,title,source_context,dest_context,element,from_key)
    }
  }
}


async function initialize_trashy_display() {
  if ( trashDB ) {
    trashDB.session_name = "$$USER_IDENTIFIER"
    try {
      let db_el = await trashDB.get_session("$$USER_IDENTIFIER")
      let store_trash = db_el.data
      g_trash_entries = {}
      for ( let adate in store_trash ) {
        g_trash_entries[adate] = JSON.parse(store_trash[adate])
      }
      let a_list = Object.keys(g_trash_entries)
      if ( a_list.length ) {
        let category = 'trash'
        install_editing(a_list,`edit-left-${category}`,category)
      }
    } catch ( e ) {
      console.log(e)
    }
  }
}


async function trash_to_db(the_date) {
  if ( trashDB ) {
    let trash_rep = JSON.stringify(g_trash_entries[the_date])
    try {
      await trashDB.add_data(trash_rep,the_date)
    } catch (e) {
      console.log(e)
    }
  }
}


function trash_to_date() {
  // get the trash map, make sure today's date is represented...
  let today = new Date()
  let y = today.getFullYear()
  let m = today.getMonth() + 1
  let d = today.getDate()
  //
  today = `${y}${m}${d}`
  _add_to("trash",today)
  //
  let entries = g_trash_entries[today]
  //
  return [today,entries]
}

function handle_drop_link_trash(event) {
  //
  event.preventDefault();
  //
  if ( event.dataTransfer ) {
    const data = event.dataTransfer.getData("text/plain");
    let [from_key,url] = get_url_map_key(data)
    //
    if ( g_current_source_context !== 'trash' ) {
      let source_context = g_current_source_context
      //
      let [a_from_list,from_map] = get_edit_lists(source_context)
      let title = title_from_context(url,source_context)      // always keep titles with the URL...
      //
      let from_list = from_map[from_key]
      if ( from_list ) {
        if ( Array.isArray(from_list) ) {
          let idx = from_list.indexOf(url)
          if ( idx >= 0 ) {
            from_list.splice(idx,1)
          }
        } else {
          if ( from_list[url] ) delete from_list[url]
        }
        //
        let [the_date,to_list] = trash_to_date() // trash list 
        if ( Array.isArray(to_list) ) {
          if ( push_if_new(to_list, url) ) {
            dirty_edit_update(true,source_context)
          }
        } else {
          if ( set_if_new(to_list, { "url" : url, "title" : title }) ) {
            dirty_edit_update(true,source_context)
          }
        }
        trash_to_db(the_date)
        show_links('trash')
        show_links(source_context)
        //
        change_save_state_move(url,title,source_context,false,from_key)
      }
    }
  }
}




function front_view(which_list) {
  let list_choice = document.getElementById("user-info-id")
  if ( list_choice ) {
    list_choice.innerHTML = which_list
  }

  let info = []
  switch ( which_list ) {
    case "topics" : {
      g_last_shown_list = g_topic_list
      info = g_finally_display_topics
      g_last_shown_map = g_finally_display_topics_map
      break
    }
    case "words" : {
      g_last_shown_list = g_word_list
      info = g_finally_display_words
      g_last_shown_map = g_finally_display_words_map
      break
    }
    case "domains" : {
      g_last_shown_list = g_domain_list
      info = g_finally_display_domains
      g_last_shown_map = g_finally_display_domains_map
      break
    }
    case "windows" : {
      g_last_shown_list = g_window_list
      info = g_finally_display_windows
      g_last_shown_map = g_finally_display_windows_map
      break
    }
    default : {
      break
    }
  }

  finally_display(info)
}


function show_links(which_list) {
  show_moveable_links(which_list)
  for ( let context of ["topics","domains","words","windows","trash"] ) {
    show_drop_operators(which_list,context)
  }
}


function new_window_object(value) {
  let wobj = {
    "link" : "/www.copious.world",
    "descr" : value,
    "tabs" : []
  }
  return wobj
}


function new_word_object(value) {
  let wobj = {
    '_count': 1,
    '_url_list' : {},
    '_word' : value,
    'keep': false
  }
  return wobj
}


function extend_lists(category,value,a_list,a_map) {
  switch ( category ) {
    case "topics"  :
    case "domains" : {
      a_list.push(value)
      a_map[value] = {}
      let keeps = g_manage_delivered[category]
      keeps[value] = {}
      break;
    }
    case "words" : {
      a_list.push(value)
      a_map[value] = []
      let keeps = g_manage_delivered["words"]
      keeps[value] = new_word_object(value)
      break;
    }
    case "windows" : {
      a_list.push(value)
      a_map[value] = []
      g_manage_delivered["windows"].push(new_window_object(value))
      break;
    }
    case "trash" : {
      a_list.push(value)
      a_map[value] = {}
      break;
    }
  }
}



function _add_to(category,value) {
  if ( value.length ) {
    let [a_list,a_map] = get_edit_lists(category)
    let b = a_map[value] 
    if ( b === undefined ) {
      dirty_edit_update(true,category)

      //  this is about saving the checked boxes and leaving them on display
      let name = `op_list_${category}`
      let checkedBoxes = document.querySelectorAll(`input[name=${name}]:checked`);
      let len = checkedBoxes.length
      let save_checks = []
      for ( let i = 0; i < len; i++ ) {
        let bx = checkedBoxes[i]
        save_checks.push(bx.id)
      }

      extend_lists(category,value,a_list,a_map)

      //  Also, take care of the editing lists....
      install_editing(a_list,`edit-left-${category}`,category)
      front_view(category)

      // put the check marks back
      for ( let bx_id of save_checks ) {
        let bx_el = document.getElementById(bx_id)
        bx_el.checked = true
      }
    }
  }
}

function add_to(category,value_fld_id) {
  let value_fld = document.getElementById(value_fld_id)
  if ( value_fld ) {
    let value = value_fld.value
    _add_to(category,value)
  }
}


function delete_from(category) {
  let [a_list,a_map] = get_edit_lists(category)
  if ( a_list && a_map ) {
    let name = `op_list_${category}`
    let checkedBoxes = document.querySelectorAll(`input[name=${name}]:checked`);
    //
    let len = checkedBoxes.length
    let sel_vals = []
    for ( let i = 0; i < len; i++ ) {
      let bx = checkedBoxes[i]
      sel_vals.push(bx.value)
    }
    //
    for ( let value of sel_vals ) {
      let idx = a_list.indexOf(value)
      if ( idx >= 0 ) {
        a_list.splice(idx,1)
        delete a_map[value]
        dirty_edit_update(true,category)

      }
    }

    add_all_deletes(category,sel_vals)

    //  Also, take care of the editing lists....
    install_editing(a_list,`edit-left-${category}`,category)
    show_links(category)
    front_view(category)
    if ( category === "trash" ) {
      let [the_date,to_list] = trash_to_date() // trash list 
      trash_to_db(the_date)
    }
    //
  }
}



function show_status(msg) {
  //
}

prep_updates()

fetch_all()
db_startup()

</script>
